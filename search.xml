<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>来偷我的狐狸了 大伙儿^^</title>
      <link href="/2020/09/16/%E9%87%8D%E7%A7%98%E7%8B%90%E7%8B%B8/"/>
      <url>/2020/09/16/%E9%87%8D%E7%A7%98%E7%8B%90%E7%8B%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="重秘狐狸（百分百前三）"><a href="#重秘狐狸（百分百前三）" class="headerlink" title="重秘狐狸（百分百前三）"></a>重秘狐狸（百分百前三）</h1><p>抢：（复活甲）大剑 护甲 （法爆）大棒 拳套</p><ol><li>不卖血（2-1升4 三个二星可以不升）</li><li>质量卡过渡 推荐 三猩红 </li><li>有天选拿天选 只要能赢 不管啥都行 一定要在三狼升 7 然后有钱D出我们的阵容</li><li>三狼把不是我们阵容的卡卖完  只要 重装天选（锤石 猪妹 剑魔） 秘书天选（猫咪 风女 蛇女）</li><li>只要狐狸有复活甲 法爆就吃分</li><li>冲<br>阵容：狐狸 猫咪 风女 蛇女（肾） 猪妹 剑魔 锤石       </li></ol><p><img src="https://imgsa.baidu.com/forum/w%3D580/sign=d9b8fc34d4b44aed594ebeec831d876a/83069313b07eca803a98c6999f2397dda04483c2.jpg"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>加油！</p><p><a href="https://www.huya.com/20244410">直播间</a></p><p>点个关注大伙！</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云顶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java终生学习，课堂笔记——13</title>
      <link href="/2019/02/04/Java13/"/>
      <url>/2019/02/04/Java13/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java终生学习，异常课堂笔记——12</title>
      <link href="/2019/01/03/Java12/"/>
      <url>/2019/01/03/Java12/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中的异常（Exception）"><a href="#Java中的异常（Exception）" class="headerlink" title="Java中的异常（Exception）"></a>Java中的异常（Exception）</h1><h2 id="异常（Exception）"><a href="#异常（Exception）" class="headerlink" title="异常（Exception）"></a>异常（Exception）</h2><pre><code>异常处理机制1、java中异常的作用是：增强程序健壮性。2、java中异常以类和对象的形式存在。</code></pre><h2 id="一：java的异常处理机制"><a href="#一：java的异常处理机制" class="headerlink" title="一：java的异常处理机制"></a>一：java的异常处理机制</h2><h3 id="1-1、异常在java中以类和对象的形式存在。那么异常的继承结构是怎样的？"><a href="#1-1、异常在java中以类和对象的形式存在。那么异常的继承结构是怎样的？" class="headerlink" title="1.1、异常在java中以类和对象的形式存在。那么异常的继承结构是怎样的？"></a>1.1、异常在java中以类和对象的形式存在。那么异常的继承结构是怎样的？</h3><pre><code>我们可以使用UML图来描述一下继承结构。画UML图有很多工具，例如：Rational Rose（收费的）、starUML等....    Object    Object下有Throwable（可抛出的）    Throwable下有两个分支：Error（不可处理，直接退出JVM）和Exception（可处理的）    Exception下有两个分支：        Exception的直接子类：编译时异常（要求程序员在编写程序阶段必须预先对这些异常进行处理，如果不处理编译器报错，因此得名编译时异常。）。        RuntimeException：运行时异常。（在编写程序阶段程序员可以预先处理，也可以不管，都行。）</code></pre><h3 id="1-2、编译时异常和运行时异常，都是发生在运行阶段。编译阶段异常是不会发生的。"><a href="#1-2、编译时异常和运行时异常，都是发生在运行阶段。编译阶段异常是不会发生的。" class="headerlink" title="1.2、编译时异常和运行时异常，都是发生在运行阶段。编译阶段异常是不会发生的。"></a>1.2、编译时异常和运行时异常，都是发生在运行阶段。编译阶段异常是不会发生的。</h3><pre><code>编译时异常因为什么而得名？    因为编译时异常必须在编译(编写)阶段预先处理，如果不处理编译器报错，因此得名。    所有异常都是在运行阶段发生的。因为只有程序运行阶段才可以new对象。    因为异常的发生就是new异常对象。</code></pre><h3 id="1-3、编译时异常和运行时异常的区别？"><a href="#1-3、编译时异常和运行时异常的区别？" class="headerlink" title="1.3、编译时异常和运行时异常的区别？"></a>1.3、编译时异常和运行时异常的区别？</h3><pre><code>    编译时异常一般发生的概率比较高。        举个例子：            你看到外面下雨了，倾盆大雨的。            你出门之前会预料到：如果不打伞，我可能会生病（生病是一种异常）。            而且这个异常发生的概率很高，所以我们出门之前要拿一把伞。            “拿一把伞”就是对“生病异常”发生之前的一种处理方式。            对于一些发生概率较高的异常，需要在运行之前对其进行预处理。    运行时异常一般发生的概率比较低。        举个例子：            小明走在大街上，可能会被天上的飞机轮子砸到。            被飞机轮子砸到也算一种异常。            但是这种异常发生概率较低。            在出门之前你没必要提前对这种发生概率较低的异常进行预处理。            如果你预处理这种异常，你将活的很累。    假设你在出门之前，你把能够发生的异常都预先处理，你这个人会更加    的安全，但是你这个人活的很累。    假设java中没有对异常进行划分，没有分为：编译时异常和运行时异常，    所有的异常都需要在编写程序阶段对其进行预处理，将是怎样的效果呢？        首先，如果这样的话，程序肯定是绝对的安全的。        但是程序员编写程序太累，代码到处都是处理异常        的代码。</code></pre><h3 id="1-4、编译时异常还有其他名字："><a href="#1-4、编译时异常还有其他名字：" class="headerlink" title="1.4、编译时异常还有其他名字："></a>1.4、编译时异常还有其他名字：</h3><pre><code>    受检异常：CheckedException    受控异常</code></pre><h3 id="1-5、运行时异常还有其它名字："><a href="#1-5、运行时异常还有其它名字：" class="headerlink" title="1.5、运行时异常还有其它名字："></a>1.5、运行时异常还有其它名字：</h3><pre><code>    未受检异常：UnCheckedException    非受控异常</code></pre><h3 id="1-6、再次强调：所有异常都是发生在运行阶段的。"><a href="#1-6、再次强调：所有异常都是发生在运行阶段的。" class="headerlink" title="1.6、再次强调：所有异常都是发生在运行阶段的。"></a>1.6、再次强调：所有异常都是发生在运行阶段的。</h3><h3 id="1-7、Java语言中对异常的处理包括两种方式："><a href="#1-7、Java语言中对异常的处理包括两种方式：" class="headerlink" title="1.7、Java语言中对异常的处理包括两种方式："></a>1.7、Java语言中对异常的处理包括两种方式：</h3><pre><code>    第一种方式：在方法声明的位置上，使用throws关键字，抛给上一级。        谁调用我，我就抛给谁。抛给上一级。    第二种方式：使用try..catch语句进行异常的捕捉。        这件事发生了，谁也不知道，因为我给抓住了。    举个例子：        我是某集团的一个销售员，因为我的失误，导致公司损失了1000元，        “损失1000元”这可以看做是一个异常发生了。我有两种处理方式，        第一种方式：我把这件事告诉我的领导【异常上抛】        第二种方式：我自己掏腰包把这个钱补上。【异常的捕捉】        张三 --&gt; 李四 ---&gt; 王五 --&gt; CEO    思考：        异常发生之后，如果我选择了上抛，抛给了我的调用者，调用者需要        对这个异常继续处理，那么调用者处理这个异常同样有两种处理方式。</code></pre><h3 id="1-8、注意：Java中异常发生之后如果一直上抛，最终抛给了main方法，main方法继续"><a href="#1-8、注意：Java中异常发生之后如果一直上抛，最终抛给了main方法，main方法继续" class="headerlink" title="1.8、注意：Java中异常发生之后如果一直上抛，最终抛给了main方法，main方法继续"></a>1.8、注意：Java中异常发生之后如果一直上抛，最终抛给了main方法，main方法继续</h3><pre><code>向上抛，抛给了调用者JVM，JVM知道这个异常发生，只有一个结果。终止java程序的执行。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java终生学习，String课堂笔记——11</title>
      <link href="/2018/12/13/Java11/"/>
      <url>/2018/12/13/Java11/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中的String类"><a href="#Java中的String类" class="headerlink" title="Java中的String类"></a>Java中的String类</h1><h2 id="一：String类"><a href="#一：String类" class="headerlink" title="一：String类"></a>一：String类</h2><h3 id="1-1、对String在内存存储方面的理解："><a href="#1-1、对String在内存存储方面的理解：" class="headerlink" title="1.1、对String在内存存储方面的理解："></a>1.1、对String在内存存储方面的理解：</h3><pre><code>    第一：字符串一旦创建不可变。    第二：双引号括起来的字符串存储在字符串常量池中。    第三：字符串的比较必须使用equals方法。    第四：String已经重写了toString()和equals()方法。</code></pre><h3 id="1-2、String的构造方法。"><a href="#1-2、String的构造方法。" class="headerlink" title="1.2、String的构造方法。"></a>1.2、String的构造方法。</h3><pre><code>    String s = &quot;abc&quot;;    String s = new String(&quot;abc&quot;);    String s = new String(byte数组);    String s = new String(byte数组, 起始下标, 长度);    String s = new String(char数组);    String s = new String(char数组, 起始下标, 长度);</code></pre><h3 id="1-3、String类常用的21个方法。"><a href="#1-3、String类常用的21个方法。" class="headerlink" title="1.3、String类常用的21个方法。"></a>1.3、String类常用的21个方法。</h3><h2 id="二：StringBuffer-StringBuilder"><a href="#二：StringBuffer-StringBuilder" class="headerlink" title="二：StringBuffer/StringBuilder"></a>二：StringBuffer/StringBuilder</h2><h3 id="2-1、StringBuffer-StringBuilder可以看做可变长度字符串。"><a href="#2-1、StringBuffer-StringBuilder可以看做可变长度字符串。" class="headerlink" title="2.1、StringBuffer/StringBuilder可以看做可变长度字符串。"></a>2.1、StringBuffer/StringBuilder可以看做可变长度字符串。</h3><h3 id="2-2、StringBuffer-StringBuilder初始化容量16"><a href="#2-2、StringBuffer-StringBuilder初始化容量16" class="headerlink" title="2.2、StringBuffer/StringBuilder初始化容量16."></a>2.2、StringBuffer/StringBuilder初始化容量16.</h3><h3 id="2-3、StringBuffer-StringBuilder是完成字符串拼接操作的，方法名：append"><a href="#2-3、StringBuffer-StringBuilder是完成字符串拼接操作的，方法名：append" class="headerlink" title="2.3、StringBuffer/StringBuilder是完成字符串拼接操作的，方法名：append"></a>2.3、StringBuffer/StringBuilder是完成字符串拼接操作的，方法名：append</h3><h3 id="2-4、StringBuffer是线程安全的。StringBuilder是非线程安全的。"><a href="#2-4、StringBuffer是线程安全的。StringBuilder是非线程安全的。" class="headerlink" title="2.4、StringBuffer是线程安全的。StringBuilder是非线程安全的。"></a>2.4、StringBuffer是线程安全的。StringBuilder是非线程安全的。</h3><h3 id="2-5、频繁进行字符串拼接不建议使用“-”"><a href="#2-5、频繁进行字符串拼接不建议使用“-”" class="headerlink" title="2.5、频繁进行字符串拼接不建议使用“+”"></a>2.5、频繁进行字符串拼接不建议使用“+”</h3><h2 id="三：八种基本数据类型对应的包装类"><a href="#三：八种基本数据类型对应的包装类" class="headerlink" title="三：八种基本数据类型对应的包装类"></a>三：八种基本数据类型对应的包装类</h2><h3 id="1-1、什么是自动装箱和自动拆箱，代码怎么写？"><a href="#1-1、什么是自动装箱和自动拆箱，代码怎么写？" class="headerlink" title="1.1、什么是自动装箱和自动拆箱，代码怎么写？"></a>1.1、什么是自动装箱和自动拆箱，代码怎么写？</h3><pre><code>    Integer x = 100; // x里面并不是保存100，保存的是100这个对象的内存地址。    Integer y = 100;    System.out.println(x == y); // true    Integer x = 128;    Integer y = 128;    System.out.println(x == y); // false</code></pre><h3 id="1-2、Integer类常用方法。"><a href="#1-2、Integer类常用方法。" class="headerlink" title="1.2、Integer类常用方法。"></a>1.2、Integer类常用方法。</h3><pre><code>    Integer.valueOf()    Integer.parseInt(&quot;123&quot;)    Integer.parseInt(&quot;中文&quot;) : NumberFormatException</code></pre><h3 id="1-3、Integer-String-int三种类型互相转换。"><a href="#1-3、Integer-String-int三种类型互相转换。" class="headerlink" title="1.3、Integer String int三种类型互相转换。"></a>1.3、Integer String int三种类型互相转换。</h3><h3 id="2、日期类"><a href="#2、日期类" class="headerlink" title="2、日期类"></a>2、日期类</h3><pre><code>2.1、获取系统当前时间    Date d = new Date();2.2、日期格式化：Date --&gt; String    yyyy-MM-dd HH:mm:ss SSS    SimpleDateFormat sdf = new SimpleDate(&quot;yyyy-MM-dd HH:mm:ss SSS&quot;);    String s = sdf.format(new Date());2.3、String --&gt; Date    SimpleDateFormat sdf = new SimpleDate(&quot;yyyy-MM-dd HH:mm:ss&quot;);    Date d = sdf.parse(&quot;2008-08-08 08:08:08&quot;);2.4、获取毫秒数    long begin = System.currentTimeMillis();    Date d = new Date(begin - 1000 * 60 * 60 * 24);</code></pre><h3 id="3、数字类"><a href="#3、数字类" class="headerlink" title="3、数字类"></a>3、数字类</h3><pre><code>3.1、DecimalFormat数字格式化    ###,###.## 表示加入千分位，保留两个小数。    ###,###.0000 表示加入千分位，保留4个小数，不够补03.2、BigDecimal    财务软件中通常使用BigDecimal</code></pre><h3 id="4、随机数"><a href="#4、随机数" class="headerlink" title="4、随机数"></a>4、随机数</h3><pre><code>4.1、怎么产生int类型随机数。    Random r = new Random();    int i = r.nextInt();4.2、怎么产生某个范围之内的int类型随机数。    Random r = new Random();    int i = r.nextInt(101); // 产生[0-100]的随机数。</code></pre><h3 id="5、枚举"><a href="#5、枚举" class="headerlink" title="5、枚举"></a>5、枚举</h3><pre><code>5.1、枚举是一种引用数据类型。5.2、枚举编译之后也是class文件。5.3、枚举类型怎么定义？    enum 枚举类型名&#123;        枚举值,枚举值2,枚举值3    &#125;5.4、当一个方法执行结果超过两种情况，并且是一枚一枚可以列举出来的时候，建议返回值类型设计为枚举类型。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java终生学习，数组课堂笔记——10</title>
      <link href="/2018/10/03/Java10/"/>
      <url>/2018/10/03/Java10/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中的数组"><a href="#Java中的数组" class="headerlink" title="Java中的数组"></a>Java中的数组</h1><h2 id="一：数组"><a href="#一：数组" class="headerlink" title="一：数组"></a>一：数组</h2><h3 id="1-1、数组的优点和缺点，并且要理解为什么。"><a href="#1-1、数组的优点和缺点，并且要理解为什么。" class="headerlink" title="1.1、数组的优点和缺点，并且要理解为什么。"></a>1.1、数组的优点和缺点，并且要理解为什么。</h3><pre><code>    第一：空间存储上，内存地址是连续的。    第二：每个元素占用的空间大小相同。    第三：知道首元素的内存地址。    第四：通过下标可以计算出偏移量。    通过一个数学表达式，就可以快速计算出某个下标位置上元素的内存地址，    直接通过内存地址定位，效率非常高。    优点：检索效率高。    缺点：随机增删效率较低，数组无法存储大数据量。    注意：数组最后一个元素的增删效率不受影响。</code></pre><h3 id="1-2、一维数组的静态初始化和动态初始化"><a href="#1-2、一维数组的静态初始化和动态初始化" class="headerlink" title="1.2、一维数组的静态初始化和动态初始化"></a>1.2、一维数组的静态初始化和动态初始化</h3><pre><code>    静态初始化：        int[] arr = &#123;1,2,3,4&#125;;        Object[] objs = &#123;new Object(), new Object(), new Object()&#125;;    动态初始化：        int[] arr = new int[4]; // 4个长度，每个元素默认值0        Object[] objs = new Object[4]; // 4个长度，每个元素默认值null</code></pre><h3 id="1-3、一维数组的遍历"><a href="#1-3、一维数组的遍历" class="headerlink" title="1.3、一维数组的遍历"></a>1.3、一维数组的遍历</h3><pre><code>    for(int i = 0; i &lt; arr.length; i++)&#123;        System.out.println(arr[i]);    &#125;</code></pre><h3 id="1-4、二维数组的静态初始化和动态初始化"><a href="#1-4、二维数组的静态初始化和动态初始化" class="headerlink" title="1.4、二维数组的静态初始化和动态初始化"></a>1.4、二维数组的静态初始化和动态初始化</h3><pre><code>    静态初始化：        int[][] arr = &#123;                                &#123;1,2,34&#125;,                                &#123;54,4,34,3&#125;,                                &#123;2,34,4,5&#125;                            &#125;;        Object[][] arr = &#123;                                &#123;new Object(),new Object()&#125;,                                &#123;new Object(),new Object()&#125;,                                &#123;new Object(),new Object(),new Object()&#125;                            &#125;;    动态初始化：        int[][] arr = new int[3][4];        Object[][] arr = new Object[4][4];        Animal[][] arr = new Animal[3][4];        // Person类型数组，里面可以存储Person类型对象，以及Person类型的子类型都可以。        Person[][] arr = new Person[2][2];        ....</code></pre><h3 id="1-5、二维数组的遍历"><a href="#1-5、二维数组的遍历" class="headerlink" title="1.5、二维数组的遍历"></a>1.5、二维数组的遍历</h3><pre><code>    for(int i = 0; i &lt; arr.length; i++)&#123; // 外层for循环负责遍历外面的一维数组。        // 里面这个for循环负责遍历二维数组里面的一维数组。        for(int j = 0; j &lt; arr[i].length; j++)&#123;            System.out.print(arr[i][j]);        &#125;        // 换行。        System.out.println();    &#125;</code></pre><h3 id="1-6、main方法上“String-args”参数的使用"><a href="#1-6、main方法上“String-args”参数的使用" class="headerlink" title="1.6、main方法上“String[] args”参数的使用"></a>1.6、main方法上“String[] args”参数的使用</h3><h3 id="1-7、数组的拷贝：System-arraycopy-方法的使用"><a href="#1-7、数组的拷贝：System-arraycopy-方法的使用" class="headerlink" title="1.7、数组的拷贝：System.arraycopy()方法的使用"></a>1.7、数组的拷贝：System.arraycopy()方法的使用</h3><pre><code>    数组有一个特点：长度一旦确定，不可变。    所以数组长度不够的时候，需要扩容，扩容的机制是：新建一个大数组，    将小数组中的数据拷贝到大数组，然后小数组对象被垃圾回收。</code></pre><h3 id="1-8、对数组中存储引用数据类型的情况，要会画它的内存结构图。"><a href="#1-8、对数组中存储引用数据类型的情况，要会画它的内存结构图。" class="headerlink" title="1.8、对数组中存储引用数据类型的情况，要会画它的内存结构图。"></a>1.8、对数组中存储引用数据类型的情况，要会画它的内存结构图。</h3><h2 id="二：算法"><a href="#二：算法" class="headerlink" title="二：算法"></a>二：算法</h2><h3 id="2-1、常见的算法："><a href="#2-1、常见的算法：" class="headerlink" title="2.1、常见的算法："></a>2.1、常见的算法：</h3><pre><code>        排序算法：            冒泡排序算法            选择排序算法        查找算法：            二分法查找        以上算法在以后的java实际开发中我们不需要使用的。        因为java已经封装好了，直接调用就行。</code></pre><h3 id="2-2、算法实际上在java中不需要精通，因为java中已经封装好了，"><a href="#2-2、算法实际上在java中不需要精通，因为java中已经封装好了，" class="headerlink" title="2.2、算法实际上在java中不需要精通，因为java中已经封装好了，"></a>2.2、算法实际上在java中不需要精通，因为java中已经封装好了，</h3><pre><code>    要排序就调用方法就行。例如：java中提供了一个数组工具类：        java.util.Arrays            Arrays是一个工具类。            其中有一个sort()方法，可以排序。静态方法，直接使用类名调用就行。            java.util.Arrays工具类。    所有方法都是静态的，直接用类名调用    主要使用的是两个方法：        二分法查找，排序    看文档，不要死记硬背。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java终生学习，课堂笔记——09</title>
      <link href="/2018/08/09/Java09/"/>
      <url>/2018/08/09/Java09/</url>
      
        <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="1、访问控制权限"><a href="#1、访问控制权限" class="headerlink" title="1、访问控制权限"></a>1、访问控制权限</h2><pre><code>1.1、访问控制权限都有哪些？    4个。    private    私有    public 公开    protected    受保护    默认1.2、以上的4个访问控制权限：控制的范围是什么？    private 表示私有的，只能在本类中访问    public 表示公开的，在任何位置都可以访问    “默认”表示只能在本类，以及同包下访问。    protected表示只能在本类、同包、子类中访问。    范围从大到小排序：public &gt; protected &gt; 默认 &gt; private1.3、访问控制权限修饰符可以修饰什么？    属性（4个都能用）    方法（4个都能用）    类（public和默认能用，其它不行。）    接口（public和默认能用，其它不行。）    .....</code></pre><h2 id="二：JDK类库的根类：Object"><a href="#二：JDK类库的根类：Object" class="headerlink" title="二：JDK类库的根类：Object"></a>二：JDK类库的根类：Object</h2><h3 id="2-1、Object"><a href="#2-1、Object" class="headerlink" title="2.1、Object"></a>2.1、Object</h3><pre><code>    任何一个类默认继承Object。就算没有直接继承，最终也会间接继承。</code></pre><h3 id="2-2、-Object类当中有哪些常用的方法？"><a href="#2-2、-Object类当中有哪些常用的方法？" class="headerlink" title="2.2、 Object类当中有哪些常用的方法？"></a>2.2、 Object类当中有哪些常用的方法？</h3><pre><code>    protected Object clone()   // 负责对象克隆的。     int hashCode()    // 获取对象哈希值的一个方法。    boolean equals(Object obj)  // 判断两个对象是否相等    String toString()  // 将对象转换成字符串形式    protected void finalize()  // 垃圾回收器负责调用的方法</code></pre><h3 id="2-3、toString-方法"><a href="#2-3、toString-方法" class="headerlink" title="2.3、toString()方法"></a>2.3、toString()方法</h3><pre><code>    以后所有类的toString()方法是需要重写的。    重写规则，越简单越明了就好。    System.out.println(引用); 这里会自动调用“引用”的toString()方法。    String类是SUN写的，toString方法已经重写了。</code></pre><h3 id="2-4、equals-方法"><a href="#2-4、equals-方法" class="headerlink" title="2.4、equals()方法"></a>2.4、equals()方法</h3><pre><code>    以后所有类的equals方法也需要重写，因为Object中的equals方法比较    的是两个对象的内存地址，我们应该比较内容，所以需要重写。    重写规则：自己定，主要看是什么和什么相等时表示两个对象相等。    基本数据类型比较实用：==    对象和对象比较：调用equals方法    String类是SUN编写的，所以String类的equals方法重写了。    以后判断两个字符串是否相等，最好不要使用==，要调用字符串对象的equals方法。    注意：重写equals方法的时候要彻底。</code></pre><h3 id="2-5、finalize-方法。"><a href="#2-5、finalize-方法。" class="headerlink" title="2.5、finalize()方法。"></a>2.5、finalize()方法。</h3><pre><code>    这个方法是protected修饰的，在Object类中这个方法的源代码是？        protected void finalize() throws Throwable &#123; &#125;</code></pre><h3 id="2-6、final-finally-finalised-区别？"><a href="#2-6、final-finally-finalised-区别？" class="headerlink" title="2.6、final finally finalised 区别？"></a>2.6、final finally finalised 区别？</h3><pre><code>（1）final：被final修饰的类，不被能继承；被final修饰的方法，不能被重写；被fianl修饰的量，为常量，只能被赋值一次；（2）finally：异常处理，和try、catch结合使用，可加可不加，用于执行一些必须执行的代码，如释放资源等；（3）finalized：Object类中的方法，其中定义了对象要被垃圾回收器回收之前，要做的一些清理工作</code></pre><h3 id="2-7、内部类和匿名内部类"><a href="#2-7、内部类和匿名内部类" class="headerlink" title="2.7、内部类和匿名内部类"></a>2.7、内部类和匿名内部类</h3><pre><code>内部类是定义在类中的类。内部类的主要作用是将逻辑上相关的类放到一起。 匿名类是特殊的内部类，没有类名。在定义类的同时，就生成该类的一个实例，并且不会在其他地方用到该类，所以不用起名字，因而又称匿名内部类。内部类内部类可以看作是外部类的一个成员，与一般类相同，内部类可以拥有自己的成员变量与成员方法，通过建立内部类对象，可以访问其成员变量和调用成员内部类可以声明成private或protected,访问原则是，在外部类中，通过一个内部类的对象引用内部类中的成员；而在内部类中，可以直接引用外部类的成员。包括静态员、实例成员、私有成员。当然，内部类也可以通过创建对象从外部类之外被调用，但是内部类必须声明成public的。匿名内部类创建匿名内部类的用意：主要是用来弥补内部类中没有定义到的方法，并能有效的简化程序代码。匿名内部类通常用来编写“事件”的程序代码。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java终生学习，final与abstract——08</title>
      <link href="/2018/06/09/Java08/"/>
      <url>/2018/06/09/Java08/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中的final与abstract"><a href="#Java中的final与abstract" class="headerlink" title="Java中的final与abstract"></a>Java中的final与abstract</h1><h2 id="一：final关键字"><a href="#一：final关键字" class="headerlink" title="一：final关键字"></a>一：final关键字</h2><pre><code>1.1、final修饰的类无法继承。1.2、final修饰的方法无法覆盖。1.3、final修饰的变量只能赋一次值。1.4、final修饰的引用一旦指向某个对象，则不能再重新指向其它对象，但该引用指向的对象内部的数据是可以修改的。1.5、final修饰的实例变量必须手动初始化，不能采用系统默认值。1.6、final修饰的实例变量一般和static联合使用，称为常量。        public static final double PI = 3.1415926;</code></pre><h2 id="二：抽象类和接口以及抽象类和接口的区别。"><a href="#二：抽象类和接口以及抽象类和接口的区别。" class="headerlink" title="二：抽象类和接口以及抽象类和接口的区别。"></a>二：抽象类和接口以及抽象类和接口的区别。</h2><h3 id="2-1、抽象类"><a href="#2-1、抽象类" class="headerlink" title="2.1、抽象类"></a>2.1、抽象类</h3><pre><code>    第一：抽象类怎么定义？在class前添加abstract关键字就行了。    第二：抽象类是无法实例化的，无法创建对象的，所以抽象类是用来被子类继承的。    第三：final和abstract不能联合使用，这两个关键字是对立的。    第四：抽象类的子类可以是抽象类。也可以是非抽象类。    第五：抽象类虽然无法实例化，但是抽象类有构造方法，这个构造方法是供子类使用的。    第六：抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中。    第七：抽象方法怎么定义？        public abstract void doSome();    第八（五颗星）：一个非抽象的类，继承抽象类，必须将抽象类中的抽象方法进行覆盖/重写/实现。    到目前为止，只是学习了抽象类的基础语法，一个类到底声明为抽象还是非抽象，    这个以后慢慢来吧。写代码多的时候，自然就理解了。    面试题（判断题）：java语言中凡是没有方法体的方法都是抽象方法。        不对，错误的。        Object类中就有很多方法都没有方法体，都是以“;”结尾的，但他们        都不是抽象方法，例如：            public native int hashCode();            这个方法底层调用了C++写的动态链接库程序。            前面修饰符列表中没有：abstract。有一个native。表示调用JVM本地程序。</code></pre><h3 id="2-2、接口的基础语法。"><a href="#2-2、接口的基础语法。" class="headerlink" title="2.2、接口的基础语法。"></a>2.2、接口的基础语法。</h3><pre><code>    1、接口是一种“引用数据类型”。    2、接口是完全抽象的。    3、接口怎么定义：[修饰符列表] interface 接口名&#123;&#125;    4、接口支持多继承。    5、接口中只有常量+抽象方法。    6、接口中所有的元素都是public修饰的    7、接口中抽象方法的public abstract可以省略。    8、接口中常量的public static final可以省略。    9、接口中方法不能有方法体。</code></pre><h3 id="2-3、接口在开发中的作用。"><a href="#2-3、接口在开发中的作用。" class="headerlink" title="2.3、接口在开发中的作用。"></a>2.3、接口在开发中的作用。</h3><pre><code>    总结一句话：三个字“解耦合”            面向接口编程，可以降低程序的耦合度，提高程序的扩展力。符合OCP开发原则。            接口的使用离不开多态机制。（接口+多态才可以达到降低耦合度。）            接口可以解耦合，解开的是谁和谁的耦合！！！            任何一个接口都有调用者和实现者。            接口可以将调用者和实现者解耦合。            调用者面向接口调用。            实现者面向接口编写实现。            以后进行大项目的开发，一般都是将项目分离成一个模块一个模块的，            模块和模块之间采用接口衔接。降低耦合度。</code></pre><h3 id="2-4、类型和类型之间的关系："><a href="#2-4、类型和类型之间的关系：" class="headerlink" title="2.4、类型和类型之间的关系："></a>2.4、类型和类型之间的关系：</h3><pre><code>is a（继承）、has a（关联）、like a（实现）</code></pre><h3 id="2-5、抽象类和接口有什么区别？"><a href="#2-5、抽象类和接口有什么区别？" class="headerlink" title="2.5、抽象类和接口有什么区别？"></a>2.5、抽象类和接口有什么区别？</h3><pre><code>抽象类是半抽象的。    接口是完全抽象的。    抽象类中有构造方法。    接口中没有构造方法。    接口和接口之间支持多继承。    类和类之间只能单继承。    一个类可以同时实现多个接口。    一个抽象类只能继承一个类（单继承）。    接口中只允许出现常量和抽象方法。</code></pre><h3 id="2-6、package和import"><a href="#2-6、package和import" class="headerlink" title="2.6、package和import"></a>2.6、package和import</h3><pre><code>    2.1、package    第一：package出现在java源文件第一行。    第二：带有包名怎么编译？javac -d . xxx.java    第三：怎么运行？java 完整类名    补充：以后说类名的时候，如果带着包名描述，表示完整类名。    如果没有带包，描述的话，表示简类名。        java.util.Scanner 完整类名。        Scanner 简类名2.2、import    import什么时候不需要？        java.lang不需要。        同包下不需要。         其它一律都需要。    怎么用？        import 完整类名;        import 包名.*;        import java.util.Scanner; // 完整类名。        // 同学的疑问：这样是不是效率比较低。        // 这个效率不低，因为编译器在编译的时候，会自动把*变成具体的类名。        import java.util.*;        // 想省懒劲不能太省了。        import java.*; 这是不允许的，因为在java语言中规定，这里的*只代表某些类的名字。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java终生学习，工具的学习——07</title>
      <link href="/2018/01/09/Java07/"/>
      <url>/2018/01/09/Java07/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中的继承开发工具"><a href="#Java中的继承开发工具" class="headerlink" title="Java中的继承开发工具"></a>Java中的继承开发工具</h1><h2 id="一：eclipse"><a href="#一：eclipse" class="headerlink" title="一：eclipse"></a>一：eclipse</h2><pre><code>IBM开发的。eclipse翻译为：日食。寓意吞并SUN公司（SUN是太阳。）    最终没有成功，SUN公司在2009年的时候被oracle甲骨文公司收购。    eclipse在以前的开发中使用非常多，但是由于IDEA工具的出现，让eclipse    的用户大大减少，目前eclipse占市场份额30%。IDEA占市场份额60%，    剩下10%是其他的开发工具。</code></pre><h2 id="二：Intellij-IDEA"><a href="#二：Intellij-IDEA" class="headerlink" title="二：Intellij IDEA"></a>二：Intellij IDEA</h2><pre><code>    提示功能比eclipse强大。更好用。</code></pre><h2 id="三：-什么是集成开发工具？"><a href="#三：-什么是集成开发工具？" class="headerlink" title="三： 什么是集成开发工具？"></a>三： 什么是集成开发工具？</h2><pre><code>    集成开发工具又称为集成开发环境，把开发中需要的东西全部集成在一起，    包括编写代码时大量的代码提示，及时的编译，程序员编写代码之后，集成    开发工具自动编译，有语法错误的时候集成开发工具会马上标红色。运行的    时候也不需要命令，直接使用鼠标操作即可。总之集成开发工具就是为了提高    开发速度。另外集成开发工具会为程序员生成很多代码，有很多代码不需要写。        及时编译        语法错误及时提醒        代码提示功能        代码自动生成功能        方便的运行        .....</code></pre><h2 id="四：IDEA-的使用"><a href="#四：IDEA-的使用" class="headerlink" title="四：IDEA 的使用"></a>四：IDEA 的使用</h2><pre><code>第一次打开的时候：会弹出一个窗口（import idea settings）    这个表示导入idea的设置，但我们是第一次使用idea工具，    没有设置过idea，所以这里选择：do not import setting...不导入设置。第二步：会让你接受条款，接受即可。第三步：don&#39;t send第四步：一直下一步（最终选择免费试用30天。）第五步：可能会让你填写email等信息，这里不填写，继续continue。第六步：弹出welcome窗口    点击create new project    注意：在IDEA当中一个project相当于eclipse当中的一个workspace。第七步：新建一个Empty Project    新建一个空的工程，选择创建工程窗口下面“最后的那一项”，Empty Project第八步：给空的工程起一个名字：javase    存储到：C:\Users\Administrator\IdeaProjects\javase    点击finish。第九步：自动弹出一个每日提示，这个每日提示可以取消掉。以后每一次打开就不再提示了。第十步：会自动弹出一个：project structure，这个窗口先取消掉。第十一步：在空的工程下新建Module（模块），IDEA中模块类似于eclipse当中的project。    eclipse的组织方式：        workspace--&gt; project    idea的组织方式：        project --&gt; module    怎么创建module?        file菜单--&gt;new --&gt; Module第十二步：在New Module窗口上点击左上角的java，然后next第十三步：给module起一个名字：chapter15第十四步：编写代码，在src目录下新建类，写代码，并运行。</code></pre><h2 id="五：IDEA工具的快捷键以及一些简单的设置"><a href="#五：IDEA工具的快捷键以及一些简单的设置" class="headerlink" title="五：IDEA工具的快捷键以及一些简单的设置"></a>五：IDEA工具的快捷键以及一些简单的设置</h2><pre><code>1.字体设置    file --&gt; settings --&gt; 输入font --&gt; 设置字体样式以及字号大小。2.快速生成main方法    psvm3.快速生成System.out.println()    sout 4.注意：IDEA是自动保存，不需要ctrl + s5.删除一行    ctrl + y5.怎么运行：    代码上右键--&gt;run    或者点击左侧的绿色箭头。    ctrl + shift + F106.左侧窗口中的列表怎么展开？怎么关闭？    左箭头关闭。    右箭头展开。    上下箭头移动。7.idea中退出任何窗口，都可以使用esc键盘。（esc就是退出）8.任何新增/新建/添加的快捷键是：    alt + insert9.窗口变大，变小：    ctrl + shift + F1210.切换java程序：从HelloWorld切换到User    alt + 右箭头     或者    alt + 左箭头11.切换窗口：    alt + 标号    alt + 1（打开，关闭）    alt + 212.提示方法的参数：ctrl + p13.注释：    单行注释：ctrl + /    多行注释：ctrl + shift + /14.idea中怎么定位方法/属性/变量？    光标停到某个单词的下面，这个单词可能是：        方法名、变量名    停到单词下面之后，按ctrl键，出现下划线，点击跳转。15.idea当中复制一行是ctrl + d</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java终生学习，继承和多态——06</title>
      <link href="/2017/11/18/Java06/"/>
      <url>/2017/11/18/Java06/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中的继承和多态"><a href="#Java中的继承和多态" class="headerlink" title="Java中的继承和多态"></a>Java中的继承和多态</h1><h2 id="一：继承extends"><a href="#一：继承extends" class="headerlink" title="一：继承extends"></a>一：继承extends</h2><p>什么是继承，有什么用？<br>        继承的作用：<br>            基本作用：子类继承父类，代码可以得到复用。（ 基本作用。）<br>            主要作用：因为有了继承关系，才有了方法覆盖和多态机制。</p><h3 id="1-继承的相关特性"><a href="#1-继承的相关特性" class="headerlink" title="1.继承的相关特性"></a>1.继承的相关特性</h3><pre><code>① B类继承A类，则称A类为超类(superclass)、父类、基类，    B类则称为子类(subclass)、派生类、扩展类。        class A&#123;&#125;        class B extends A&#123;&#125;        我们平时聊天说的比较多的是：父类和子类。        superclass 父类        subclass 子类    ② java 中的继承只支持单继承，不支持多继承，C++中支持多继承，    这也是 java 体现简单性的一点，换句话说，java 中不允许这样写代码：        class B extends A,C&#123; &#125; 这是错误的。    ③ 虽然 java 中不支持多继承，但有的时候会产生间接继承的效果，    例如：class C extends B，class B extends A，也就是说，C 直接继承 B，    其实 C 还间接继承 A。    ④ java 中规定，子类继承父类，除构造方法不能继承之外，剩下都可以继承。    但是私有的属性无法在子类中直接访问。(父类中private修饰的不能在子类中    直接访问。可以通过间接的手段来访问。)    ⑤ java 中的类没有显示的继承任何类，则默认继承 Object类，Object类是     java 语言提供的根类（老祖宗类），也就是说，一个对象与生俱来就有     Object类型中所有的特征。    ⑥ 继承也存在一些缺点，例如：CreditAccount 类继承 Account 类会导致它    们之间的耦合度非常高，Account 类发生改变之后会马上影响到 CreditAccount 类</code></pre><h2 id="二：方法覆盖"><a href="#二：方法覆盖" class="headerlink" title="二：方法覆盖"></a>二：方法覆盖</h2><h3 id="2-1、什么时候考虑使用方法覆盖？"><a href="#2-1、什么时候考虑使用方法覆盖？" class="headerlink" title="2.1、什么时候考虑使用方法覆盖？"></a>2.1、什么时候考虑使用方法覆盖？</h3><pre><code>父类中的方法无法满足子类的业务需求，子类有必要对继承过来的方法进行覆盖。</code></pre><h3 id="2-2、什么条件满足的时候构成方法覆盖？"><a href="#2-2、什么条件满足的时候构成方法覆盖？" class="headerlink" title="2.2、什么条件满足的时候构成方法覆盖？"></a>2.2、什么条件满足的时候构成方法覆盖？</h3><pre><code>第一：有继承关系的两个类第二：具有相同方法名、返回值类型、形式参数列表第三：访问权限不能更低。第四：抛出异常不能更多。</code></pre><h3 id="2-3、关于Object类中toString-方法的覆盖？"><a href="#2-3、关于Object类中toString-方法的覆盖？" class="headerlink" title="2.3、关于Object类中toString()方法的覆盖？"></a>2.3、关于Object类中toString()方法的覆盖？</h3><pre><code>toString()方法存在的作用就是：将java对象转换成字符串形式。大多数的java类toString()方法都是需要覆盖的。因为Object类中提供的toString()方法输出的是一个java对象的内存地址。至于toString()方法具体怎么进行覆盖？格式可以自己定义，或者听需求的。（听项目要求的。）</code></pre><h3 id="2-4、方法重载和方法覆盖有什么区别？"><a href="#2-4、方法重载和方法覆盖有什么区别？" class="headerlink" title="2.4、方法重载和方法覆盖有什么区别？"></a>2.4、方法重载和方法覆盖有什么区别？</h3><pre><code>方法重载发生在同一个类当中。方法覆盖是发生在具有继承关系的父子类之间。方法重载是一个类中，方法名相同，参数列表不同。方法覆盖是具有继承关系的父子类，并且重写之后的方法必须和之前的方法一致：    方法名一致、参数列表一致、返回值类型一致。</code></pre><h2 id="三：多态"><a href="#三：多态" class="headerlink" title="三：多态"></a>三：多态</h2><pre><code>多种形态，多种状态，编译和运行有两个不同的状态。    编译期叫做静态绑定。    运行期叫做动态绑定多态的典型代码：父类型的引用指向子类型的对象。多态在开发中的作用是：    降低程序的耦合度，提高程序的扩展力。多态存在的三个必要条件    继承    重写    父类引用指向子类对象    Parent p = new Child();多态的重点以及结论    无论向上转型还是向下转型，都要有继承关系。    Animal a = new Cat();    a.move(); 编译阶段和运行阶段绑定的move方法不一样（向上转型）    if(a instanceof Cat)&#123;             Cat c = (Cat)a;             &#125;</code></pre><h2 id="四：super关键字"><a href="#四：super关键字" class="headerlink" title="四：super关键字"></a>四：super关键字</h2><pre><code>super能出现在实例方法和构造方法中。super的语法是：“super.”、“super()”super不能使用在静态方法中。super. 大部分情况下是可以省略的。super.什么时候不能省略呢？    父类和子类中有同名属性，或者说有同样的方法，    想在子类中访问父类的，super. 不能省略。super() 只能出现在构造方法第一行，通过当前的构造方法去调用“父类”中的构造方法，目的是：创建子类对象的时候，先初始化父类型特征。super的使用：    super.属性名                【访问父类的属性】    super.方法名(实参)        【访问父类的方法】    super(实参)                    【调用父类的构造方法】</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java终生学习，面向对象——05</title>
      <link href="/2017/11/11/Java05/"/>
      <url>/2017/11/11/Java05/</url>
      
        <content type="html"><![CDATA[<h1 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h1><h2 id="一：面向对象包括三大特征（四大）"><a href="#一：面向对象包括三大特征（四大）" class="headerlink" title="一：面向对象包括三大特征（四大）"></a>一：面向对象包括三大特征（四大）</h2><pre><code>抽象封装继承多态任何一个面向对象的编程语言都包括这三个特征例如：    python也有封装 继承 多态。    java  也有封装 继承 多态。java只是面向对象编程语言中的一种。    除了java之外，还有其它很多很多的编程语言也是面向对象的。</code></pre><h2 id="二：类和对象的概念"><a href="#二：类和对象的概念" class="headerlink" title="二：类和对象的概念"></a>二：类和对象的概念</h2><pre><code>  类 -- 【实例化】--&gt; 对象(实例)对象 --【抽象】--&gt; 类类 = 属性 + 方法</code></pre><h2 id="三：类的定义"><a href="#三：类的定义" class="headerlink" title="三：类的定义"></a>三：类的定义</h2><pre><code>[修饰符列表] class 类名 &#123;        //类体 = 属性 + 方法        // 属性在代码上以“变量”的形式存在（描述状态）        // 方法描述动作/行为    &#125;    ps:修饰符列表可以省略。</code></pre><h2 id="三：对象的定义"><a href="#三：对象的定义" class="headerlink" title="三：对象的定义"></a>三：对象的定义</h2><pre><code>对象又被称为实例。实例变量实际上就是：对象级别的变量。</code></pre><h2 id="四：对象和引用的区别"><a href="#四：对象和引用的区别" class="headerlink" title="四：对象和引用的区别"></a>四：对象和引用的区别</h2><pre><code>对象：通过new出来的，在堆内存中存储。引用：但凡是变量，并且该变量中保存了内存地址指向了堆内存当中的对象。</code></pre><h2 id="五：面向对象的首要特征：封装"><a href="#五：面向对象的首要特征：封装" class="headerlink" title="五：面向对象的首要特征：封装"></a>五：面向对象的首要特征：封装</h2><pre><code>封装的作用：    第一个作用：保证内部结构的安全。    第二个作用：屏蔽复杂，暴露简单。怎么进行封装，代码怎么实现？    第一步：属性私有化（使用private关键字进行修饰。）    第二步：1个属性对外提供两个set和get方法。外部程序只能通过set方法修改，只能通过get方法读取    (set和get方法都是实例方法，不能带static。    不带static的方法称为实例方法，实例方法的调用必须先new对象。)Setpublic void set+属性名首字母大写(1个参数)&#123;                xxx = 1个参数;            &#125;getpublic 返回值类型 get+属性名首字母大写(无参)&#123;                return xxx;            &#125;</code></pre><h2 id="六：static关键字"><a href="#六：static关键字" class="headerlink" title="六：static关键字"></a>六：static关键字</h2><pre><code>static修饰的统一都是静态的，都是类相关的，不需要new对象。直接采用“类名.”访问。当一个属性是类级别的属性，所有对象的这个属性的值是一样的，建议定义为静态变量。</code></pre><h2 id="七：this关键字"><a href="#七：this关键字" class="headerlink" title="七：this关键字"></a>七：this关键字</h2><pre><code>1.1、this是一个关键字，是一个引用，保存内存地址指向自身。1.2、this可以使用在实例方法中，也可以使用在构造方法中。1.3、this出现在实例方法中其实代表的是当前对象。1.4、this不能使用在静态方法中。1.5、this. 大部分情况下可以省略，但是用来区分局部变量和实例变量的时候不能省略。1.6、this() 这种语法只能出现在构造方法第一行，表示当前构造方法调用本类其他的构造方法，目的是代码复用。</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java终生学习，关于方法——04</title>
      <link href="/2017/10/28/Java04/"/>
      <url>/2017/10/28/Java04/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中的方法"><a href="#Java中的方法" class="headerlink" title="Java中的方法"></a>Java中的方法</h1><h2 id="一：方法重载overload"><a href="#一：方法重载overload" class="headerlink" title="一：方法重载overload"></a>一：方法重载overload</h2><pre><code>1.1、什么情况下我们考虑使用方法重载机制？    当功能相似的时候，建议将方法名定义为一致的，    这样代码美观，又方便编程。    注意：如果功能不相似，坚决要让方法名不一致。1.2、代码满足什么条件的时候构成了方法重载？    条件1：在同一个类当中    条件2：方法名相同    条件3：形式参数列表不同（类型、个数、顺序）    注意：        方法重载和返回值类型无关，和修饰符列表无关。1.3、方法重载的优点？    代码美观    方便代码的编写</code></pre><h2 id="二：方法递归"><a href="#二：方法递归" class="headerlink" title="二：方法递归"></a>二：方法递归</h2><pre><code>2.1、需要理解什么是方法递归？    方法自身调用自身。2.2、使用递归的时候，必须添加结束条件，没有结束条件，会发生栈内存溢出错误。    StackOverflowError    原因：一直压栈，没有弹栈，栈内存不够用。2.3、能够使用循环代替递归的尽量使用循环，循环的执行耗费内存少一些，递归耗费内存相对多一些，另外递归使用不当很容易内存溢出，JVM停止工作。2.5、当递归有结束条件，并且结束条件合法的时候，就一定不会内存溢出吗？    也不一定。可能递归的太深了。2.6、一些递归方面的经验    在实际的开发中遇到递归导致的栈内存溢出错误是怎么办？        第一步：先检查结束条件是否正确。        第二步：如果正确，可以调整JVM的栈内存大小。(java -X)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java终生学习，关于方法——03</title>
      <link href="/2017/10/17/Java03/"/>
      <url>/2017/10/17/Java03/</url>
      
        <content type="html"><![CDATA[<h1 id="Java中的方法"><a href="#Java中的方法" class="headerlink" title="Java中的方法"></a>Java中的方法</h1><h2 id="1、方法是什么？"><a href="#1、方法是什么？" class="headerlink" title="1、方法是什么？"></a>1、方法是什么？</h2><pre><code>方法是一段可以完成某个特定功能的并且可以被重复利用的代码片段。方法的出现，让代码具有了很强的复用性。</code></pre><h2 id="2、方法最难实现的是："><a href="#2、方法最难实现的是：" class="headerlink" title="2、方法最难实现的是："></a>2、方法最难实现的是：</h2><pre><code>根据业务怎么进行方法的抽取。方法的返回值类型定义为什么？方法的名字叫什么？方法的形式参数列表定义为什么？....一个方法就是一个独立的功能。</code></pre><h2 id="3、方法的定义"><a href="#3、方法的定义" class="headerlink" title="3、方法的定义"></a>3、方法的定义</h2><pre><code>[修饰符列表] 返回值类型 方法名(形式参数列表)&#123;    方法体; &#125;</code></pre><h2 id="4、方法的每一个细节学习"><a href="#4、方法的每一个细节学习" class="headerlink" title="4、方法的每一个细节学习"></a>4、方法的每一个细节学习</h2><pre><code> 4.1、修饰符列表：可选项，目前先写成：public static  4.2、怎么理解返回值？返回值是一个方法执行结束之后的结果。 4.3、返回值类型都可以指定哪些类型？4.4、返回值和“return语句”的关系。4.5、方法名只要是合法的标识符就行，首字母小写，后面每个单词首字母大写。见名知意。4.6、形式参数列表4.7、方法体：方法体当中的代码遵循自上而下的顺序依次逐行执行。</code></pre><h2 id="5、JVM的内存结构中三块比较重要的内存空间。"><a href="#5、JVM的内存结构中三块比较重要的内存空间。" class="headerlink" title="5、JVM的内存结构中三块比较重要的内存空间。"></a>5、JVM的内存结构中三块比较重要的内存空间。</h2><pre><code>方法区：    保存所有的class文件和static变量与方法    类加载器首先将代码加载到这里。堆内存：    存储的是一切new出来的对象。栈内存：    存放基本类型的变量和对象的引用变量（局部变量）。</code></pre><h2 id="6、关于数据结构中的栈数据结构"><a href="#6、关于数据结构中的栈数据结构" class="headerlink" title="6、关于数据结构中的栈数据结构"></a>6、关于数据结构中的栈数据结构</h2><pre><code>原则：    后进先出    先进后出栈数据结构相关的术语：    栈帧：永远指向栈顶部的元素（栈顶元素具有活跃权。）    栈顶元素    栈底元素    压栈，入栈，进栈，push    弹栈，出栈，pop</code></pre><h2 id="7、分析程序运行过程中的内存变化"><a href="#7、分析程序运行过程中的内存变化" class="headerlink" title="7、分析程序运行过程中的内存变化"></a>7、分析程序运行过程中的内存变化</h2><pre><code>方法只定义不调用是不会执行的。方法调用时：压栈 （在栈中给该方法分配空间）方法执行结束时：弹栈（将该方法占用的空间释放，局部变量的内存也释放。）</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java终生学习，戒骄戒躁——02</title>
      <link href="/2017/09/30/Java02/"/>
      <url>/2017/09/30/Java02/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-01"><a href="#Java-01" class="headerlink" title="Java 01"></a>Java 01</h1><h2 id="一：控制语句"><a href="#一：控制语句" class="headerlink" title="一：控制语句"></a>一：控制语句</h2><h3 id="2-1、控制语句的出现"><a href="#2-1、控制语句的出现" class="headerlink" title="2.1、控制语句的出现"></a>2.1、控制语句的出现</h3><p>可以让我们的程序具有逻辑性/条理性，可以使用控制语句来实现一个“业务”了。</p><h3 id="2-2、控制语句包括几类？"><a href="#2-2、控制语句包括几类？" class="headerlink" title="2.2、控制语句包括几类？"></a>2.2、控制语句包括几类？</h3><pre><code>    3类：        选择语句        循环语句        转向语句</code></pre><h3 id="2-3、选择语句也可以叫做分支语句"><a href="#2-3、选择语句也可以叫做分支语句" class="headerlink" title="2.3、选择语句也可以叫做分支语句"></a>2.3、选择语句也可以叫做分支语句</h3><pre><code>    if语句    switch语句</code></pre><h3 id="2-4、循环语句：主要循环反复的去执行某段特定的代码块"><a href="#2-4、循环语句：主要循环反复的去执行某段特定的代码块" class="headerlink" title="2.4、循环语句：主要循环反复的去执行某段特定的代码块"></a>2.4、循环语句：主要循环反复的去执行某段特定的代码块</h3><pre><code>    for循环    while循环    do..while..循环</code></pre><h3 id="2-5、转向语句"><a href="#2-5、转向语句" class="headerlink" title="2.5、转向语句"></a>2.5、转向语句</h3><pre><code>    break    continue    return（这个目前先不需要学习，后面讲方法的时候会使用。）</code></pre><h2 id="二：选择语句-分支语句"><a href="#二：选择语句-分支语句" class="headerlink" title="二：选择语句/分支语句"></a>二：选择语句/分支语句</h2><pre><code>if</code></pre><h2 id="三：选择语句"><a href="#三：选择语句" class="headerlink" title="三：选择语句"></a>三：选择语句</h2><pre><code>switch</code></pre><h2 id="四：循环语句"><a href="#四：循环语句" class="headerlink" title="四：循环语句"></a>四：循环语句</h2><pre><code>    for循环    while循环    do..while循环</code></pre><h2 id="五：什么是循环语句，为什么要使用这种语句？"><a href="#五：什么是循环语句，为什么要使用这种语句？" class="headerlink" title="五：什么是循环语句，为什么要使用这种语句？"></a>五：什么是循环语句，为什么要使用这种语句？</h2><pre><code>因为在现实世界当中，有很多事情都是需要反复/重复的去做。对应到程序当中，如果有一块代码需要重复执行，此时为了减少代码量，我们使用循环语句。</code></pre><h2 id="六：转向语句"><a href="#六：转向语句" class="headerlink" title="六：转向语句"></a>六：转向语句</h2><pre><code>break;continue;return;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java初次见面，请多关照——01</title>
      <link href="/2017/09/19/Java01/"/>
      <url>/2017/09/19/Java01/</url>
      
        <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="一：Java开发环境"><a href="#一：Java开发环境" class="headerlink" title="一：Java开发环境"></a>一：Java开发环境</h2><h3 id="1、常用的DOS命令"><a href="#1、常用的DOS命令" class="headerlink" title="1、常用的DOS命令"></a>1、常用的DOS命令</h3><pre><code>1.1、怎么打开DOS命令   窗口win键 + r （组合键）：可以打开“运行”窗口在运行窗口文本框中输入: cmd然后回车1.2、什么是DOS命令呢？在DOS命令窗口中才可以输入并执行DOS命令。在最初的windows计算机中没有图形界面的，只有DOS命令窗口。也就是说通过执行DOS命令窗口可以完全完成文件的新建、编辑、保存、删除等一系列操作。</code></pre><h3 id="2-文本编辑快捷键"><a href="#2-文本编辑快捷键" class="headerlink" title="2.文本编辑快捷键"></a>2.文本编辑快捷键</h3><pre><code>复制  ctrl + c粘贴  ctrl + v剪切  ctrl + x保存  ctrl + s撤销  ctrl + z重做  ctrl + y回到行首：home键回到行尾：end键当光标在行尾，怎么选中一行？    shift + home键当光标在行首，怎么选中一行？    shift + end键回到文件头：ctrl + home回到文件尾：ctrl + end全选：ctrl + a查找：ctrl + f选中一个单词：鼠标双击选中一行：鼠标连续击3次不用鼠标选中一个单词：ctrl + shift + 右箭头/左箭头</code></pre><h2 id="二：数据类型-8种"><a href="#二：数据类型-8种" class="headerlink" title="二：数据类型(8种)"></a>二：数据类型(8种)</h2><h3 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1.基本数据类型"></a>1.基本数据类型</h3><pre><code>Byte(-128-127)   short int(-2^31-2^31-1) longfloatdoublebooleanchar  (1 2 4 8 4 8 1 2)</code></pre><h3 id="2-引用数据类型"><a href="#2-引用数据类型" class="headerlink" title="2.引用数据类型"></a>2.引用数据类型</h3><pre><code>字符串型String属于引用数据类型。String字符串不属于基本数据类型范畴。java中除了基本数据类型之外，剩下的都是引用数据类型。引用数据类型后期面向对象的时候才会接触。</code></pre><h3 id="3-类型转换的时候需要遵循哪些规则？"><a href="#3-类型转换的时候需要遵循哪些规则？" class="headerlink" title="3.类型转换的时候需要遵循哪些规则？"></a>3.类型转换的时候需要遵循哪些规则？</h3><pre><code>第一条：八种基本数据类型中，除 boolean 类型不能转换，剩下七种类型之间都可以进行转换；第二条：如果整数型字面量没有超出 byte,short,char 的取值范围，可以直接将其赋值给byte,short,char 类型的变量；第三条：小容量向大容量转换称为自动类型转换，容量从小到大的排序为：byte &lt; short(char) &lt; int &lt; long &lt; float &lt; double，其中 short和 char 都占用两个字节，但是char 可以表示更大的正整数；第四条：大容量转换成小容量，称为强制类型转换，编写时必须添加“强制类型转换符”，但运行时可能出现精度损失，谨慎使用；第五条：byte,short,char 类型混合运算时，先各自转换成 int 类型再做运算；第六条：多种数据类型混合运算，各自先转换成容量最大的那一种再做运算；</code></pre><h3 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4.运算符"></a>4.运算符</h3><pre><code>算术运算符：    + - * / % ++ --关系运算符：    &gt; &gt;= &lt; &lt;= == != 逻辑运算符：    &amp; | ! &amp;&amp; ||赋值运算符：    = += -= *= /= %=三目运算符：    布尔表达式 ? 表达式1 : 表达式2字符串连接运算符：    +</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2017/09/01/myfirstblog/"/>
      <url>/2017/09/01/myfirstblog/</url>
      
        <content type="html"><![CDATA[<h1 id="生活不易，小查叹气"><a href="#生活不易，小查叹气" class="headerlink" title="生活不易，小查叹气"></a>生活不易，小查叹气</h1><p>这是我第一篇博客，也不知道写个啥，总之加油吧！<br><img src="https://imgsa.baidu.com/forum/w%3D580/sign=d9b8fc34d4b44aed594ebeec831d876a/83069313b07eca803a98c6999f2397dda04483c2.jpg"></p><h2 id="尽管大学不如我所愿，但我会在尘埃落定前奋力一搏。"><a href="#尽管大学不如我所愿，但我会在尘埃落定前奋力一搏。" class="headerlink" title="尽管大学不如我所愿，但我会在尘埃落定前奋力一搏。"></a>尽管大学不如我所愿，但我会在尘埃落定前奋力一搏。</h2><p>加油！</p><h2 id="直播"><a href="#直播" class="headerlink" title="直播"></a>直播</h2><p><a href="https://www.huya.com/20244410">我的直播间</a></p><p>点个关注大伙！</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
